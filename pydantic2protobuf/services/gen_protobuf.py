from pathlib import Path

import stringcase

from pydantic2protobuf.services.to_proto import pydantic_to_proto
from pydantic2protobuf.tools.to_proto import PYTHON_TO_PROTOBUF_TYPES, gen_all_proto_msg_from_routes, is_type_iterable


def gen_protobuf_from_routes(routes, service_name: str = "Service"):
    requests_proto_msg = []
    responses_proto_msg = []
    services_definitions = []

    for route in routes:
        request_body_params = route.dependant.body_params

        service_request_proto = "google.protobuf.Empty"
        if request_body_params:
            assert len(request_body_params) == 1
            body_param = request_body_params[0]
            service_request_proto = ""
            if is_type_iterable(body_param.outer_type_):
                service_request_proto = "stream "
            request_type = body_param.type_
            if "Request" in request_type.__name__:
                request_proto_msg = pydantic_to_proto(request_type, prefix_name="Do")
                responses_proto_msg.append(request_proto_msg)
                service_request_proto += f"Do{request_type.__name__}"
            else:
                service_request_proto += request_type.__name__

        response_field = route.response_field
        service_response_proto = "google.protobuf.Empty"
        if response_field:
            service_response_proto = ""
            if is_type_iterable(response_field.outer_type_):
                service_response_proto = "stream "
            response_type = response_field.type_
            if "Response" in response_type.__name__:
                response_proto_msg = pydantic_to_proto(response_type, prefix_name="Do")
                requests_proto_msg.append(response_proto_msg)
                service_response_proto += f"Do{response_type.__name__}"
            else:
                # not follow the "Response" pattern but can be valid
                proto_type_name = response_type.__name__
                if response_type in PYTHON_TO_PROTOBUF_TYPES:
                    proto_type_name = f"D{stringcase.camelcase(f'o_{route.name}')}Response"
                    response_proto_msg = f"""\
    message {proto_type_name} {{
        {PYTHON_TO_PROTOBUF_TYPES[response_type]} response = 1;
    }}"""
                    requests_proto_msg.append(response_proto_msg)

                service_response_proto += proto_type_name

        service_definition = f"rpc do_{route.name} ({service_request_proto}) returns ({service_response_proto});"
        services_definitions.append(service_definition)

    print(
        f"// Generated by {Path(__file__).resolve()}.  DO NOT EDIT!",
        "\n",
        f"""
syntax = "proto3";

// https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#struct
import "google/protobuf/struct.proto";
import "google/protobuf/wrappers.proto";
import "google/protobuf/empty.proto";

service {service_name} {{""",
        "\n",
        "\n".join(f"\t{service_definition}" for service_definition in services_definitions),
        "\n",
        "}",
        "\n",
        "\n".join(requests_proto_msg),
        "\n",
        "\n".join(responses_proto_msg),
        "\n".join(
            pydantic_to_proto(model_meta_class)
            for model_meta_class in gen_all_proto_msg_from_routes(routes)
            if "Request" not in str(model_meta_class) and "Response" not in str(model_meta_class)
        ),
    )
